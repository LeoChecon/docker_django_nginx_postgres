# Presentation

*Esse arquivo tambÃ©m estÃ¡ disponÃ­vel em PortuguÃªs! (README PT-BR.md)!*

## Why did I create this repository?

Let's say you're new to programming and have started to learn how to use `django` to create web pages. All is well and good, until you find out that your beloved `python manage.py runserver` can't keep up with you when the game really kicks off.

You do a search and quickly discover that it's a little more complicated than you thought, and soon words like `web server`, `reverse proxy`, `ports 80 and 443`, `environment variables`, `Virtual Machines`, etc., show up...

![til](examples/monty-python-gif01.gif)

"Holy shit, I barely know how to use `django` and I already have to learn all these related technologies to do a mere "Hello World!" in a production environment!"* ðŸ˜­

## If you're feeling this way, you've come to the right place!

Creating a `django` application and using it in a production environment can be **exhausting and frustrating** when you're starting to learn to program. In fact, several technologies are needed to deploy such an application, of which we can mention at least the following:

* `Nginx`
* `Gunicorn`
* A relational database such as `Postgres` or `Mysql`

Obviously, each of these technologies is a world appart and has its minutiae, which require **dedication and time** of study from the programmer so that they are optimally setup within the context of their application.

I don't intend with this **model** to solve all your deployment problems, but at least give you a guide on how to start a project and reduce your comings and goings to `Stackoverflow` to create a basic and functional configuration for a production environment.

![til](examples/monty-python-gif02.gif)

## How to use this model?

### Do I need to know `Docker` to test this model?

NO! Just install the following **requirements** and follow the guidelines below.

**Requirements:**

* Python 3 (https://realpython.com/installing-python/)
* Docker (https://docs.docker.com/engine/install/)

**Guidelines:**

There are three distinct and independent options for using this model, they are: **development mode**, **production mode with docker compose**, **production mode with docker swarm**.

After cloning the repository to the desired folder on your computer, open a command prompt or terminal at the root of the repository and follow the instructions below...

### Development mode

1. Install the python's `pipenv` library (https://pipenv.pypa.io/en/latest/index.html)
2. Start a virtual environment: `pipenv shell`
3. Install the project's dependencies: `pipenv install`;
4. Change directory to the docker_django folder and start the `django` development server: `python manage.py runserver --insecure`

*In development mode we chose to use Sqlite3 as a database so as not to require you to download a version of Postgres on your machine.*

*The `--insecure` flag is required in order to allow django's web server to display static files when `DEBUG = False` in `settings.py`.*

### Production mode with docker compose

To start the application, do the following:

1. Check if lines 94 and 96 of `docker-compose.yml` are commented out. If not, **COMMENT THEM**. To do so, type a # at the beginning of the line and save the file;
2. Start `Docker`
3. Run the command `docker compose up`
4. Wait until all **three services** are started correctly and running

> You can confirm that the services have started correctly and are running in the docker dashboard...![til](examples/docker%20compose%20dashboard%20-%20containers.png)
>... or using the `docker compose ps` command in another terminal![til](examples/docker%20compose%20ps.png)

5. Open the `localhost:8080` page in your browser

To close the application, do the following:

1. In the terminal or command prompt type `Ctrl+C`
2. (optional) Enter the command `docker compose down -v --rmi local` to completely delete the files generated by compose mode, including the database and containers created;

### Production mode with docker swarm mode

To start the application, do the following:

1. Check if lines 94 and 96 of `docker-compose.yml` are commented out. If yes, **UNCOMMENT THEM**. To do so, delete the # at the beginning of the line and save the file;
2. Start `Docker`
3. Start `swarm mode` by typing the command `docker swarm init`
4. Build the container images: `docker compose build`
5. Run the application: `docker stack deploy -c docker-compose.yml my_stack_name`
6. Wait until all **three services** are started correctly and running

> You can confirm that the services are started correctly and running in the docker dashboard...![til](examples/docker%20dashboard%20-%20containers.png)
>... or using the command `docker stack ps my_stack_name`![til](examples/docker%20stack%20ps%20command%20output.png)

7. Open the `localhost:8080` page in your browser

To close the application, do the following:

1. Run the command `docker stack rm my_stack_name`
2. (optional) Exit swarm mode: `docker swarm leave --force`

## Understanding the code

### Hierarchy of files and folders

* **docker_django folder**:
  * django application files (`docker_django`);
  * dummy-app folder `new_app`;
  * Folder automatically generated by the `python manage.py collectstatic` command;
  * SQLite database file, used for testing in development mode (`db.sqlite3`);
  * Configuration file for starting the `django` Docker service (`django_entrypoint.sh`);
  * Gunicorn configuration file (`gunicorn.conf.py`);
* **nginx config folder**:
  * `nginx` configuration files, used by `Docker` to create the respective container;
* **Secret_files folder**: contains the files used by `docker secrets` to assemble the containers.
  * database_name: the name of the database;
  * database_password: the password of the database;
  * database_user: (guess what!) the user of the database;
  * django_key: secret_key's value present in django's `settings.py`;
* **.Dockerfile**: used to build containers locally;
* **docker-compose.yml file**: used to build containers and run `Docker`;
* **Pipfile and Pipfile.lock files:** used to build a `virtualenv` for local testing using the `pipenv` library (https://pipenv.pypa.io/en/latest/index.html);
* **Requirements.txt file**: used to build a `virtualenv` for local testing using `pip` (https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/);
  * Attention: `Docker` uses this file to download and install the project's dependencies in the respective container;

### Docker Settings

Three distinct services were created using `Docker`, they are:

| Service | Dockerfile |
| --- | --- |
| database | _postgres.Dockerfile |
| webserver | _nginx.Dockerfile |
| django | _django.Dockerfile |

If you want to make use of additional `environment variables`, it is recommended to add them directly in the `docker-compose.yml` file

### `django` settings

The `django` application is inside the **docker_django** folder: no big deal, configure as you like. If you want to change `STATIC_ROOT` and `STATIC_URL` you may need to make adjustments to the `nginx` configuration files - otherwise everything is already set up and working.

### `nginx` settings

*Under construction...*

## Why use Docker?

> `Docker` takes away repetitive, mundane configuration tasks and is used throughout the development lifecycle for fast, easy and portable application development â€“ desktop and cloud. Dockerâ€™s comprehensive end to end platform includes UIs, CLIs, APIs and security that are engineered to work together across the entire application delivery lifecycle. [ https://www.docker.com/ ]

`Docker` is a tool that allows you to assemble the parts of your application into independent and isolated services, helping to deploy the application. It makes it much easier to run the app in different environments, as long as that environment is capable of running Docker. This reduces - and a lot! - the time needed to set up `Virtual Machines`, for example.